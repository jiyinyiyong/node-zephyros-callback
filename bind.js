// Generated by CoffeeScript 1.6.3
var call, client, delay, id, net, str, unit,
  __slice = [].slice;

net = require('net');

unit = function(x) {
  return x + '\r\n';
};

str = function(x) {
  switch (typeof x) {
    case 'object':
      return JSON.stringify(x);
    case 'string':
      return x;
    default:
      return String(x);
  }
};

delay = function(t, f) {
  return setTimeout(f, t);
};

id = {
  current: 0,
  make: function() {
    this.current += 1;
    return this.current;
  }
};

call = [];

client = net.connect({
  port: 1235
}, function() {
  return console.log('connected');
});

exports.send = function() {
  var args, callback, message, method, msg_id, receiver_id, _i;
  receiver_id = arguments[0], method = arguments[1], args = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), callback = arguments[_i++];
  msg_id = id.make();
  message = [msg_id, receiver_id, method].concat(__slice.call(args));
  console.log('message is', message);
  client.write(unit(str(message)));
  return call[msg_id] = {
    callback: callback,
    message: message
  };
};

client.on('data', function(message) {
  var msg_id, value, _ref, _ref1;
  _ref = JSON.parse(message), msg_id = _ref[0], value = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  if (call[msg_id] != null) {
    call[msg_id].callback(value);
    if ((_ref1 = call[msg_id].message[2]) !== 'bind' && _ref1 !== 'listen') {
      return delete call[msg_id];
    }
  } else {
    return console.log('no callback for', message);
  }
});

/*
//@ sourceMappingURL=bind.map
*/
